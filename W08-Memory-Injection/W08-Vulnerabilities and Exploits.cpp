/***********************************************************************
* Program:
*    Lab 08, Vulnerabilities and Exploits
*    Brother Wilson, CSE 453
* Author:
*    Benjamin Hansen, John Reiley, Joseph Sanderson, Justen Neeley, 
*    Garrett Smith
* Summary: 
*    This program is designed to demonstrate memory injection vulnerabilities.
*
************************************************************************/

#include <iostream>
#include <string>
#include <cstring>
#include <fstream>
#include <cassert>
#include <iomanip>
using namespace std;

void stackExploit();
void heapExploit();
void arrayExploit();
void intExploit();
void arcExploit();
void arcWorking();
void subterfugeExploit();
void vtableExploit();
void ansiExploit();
void ansiWorking();
void arrayVulnerability();
void arrayWorking();
void arrayExploit();

/************************************************
 * CONVERT TO STRING
 * Convert the data from p into a human-readable string
 * by removing all the unprintable characters and replacing
 * them with a dot
 ***********************************************/
string displayCharArray(const char * p)
{
   string output;
   for (int i = 0; i < 8; i++)
      output += string(" ") + (p[i] >= ' ' && p[i] <= 'z' ? p[i] : '.');
   return output;
}

/************************************************
 * DISPLAY CALL STACK
 * Display the call stack at the given long pointer.
 * Display numLongs number of rows.
 ************************************************/
void displayCallStack(long * p, const int numLongs)
{
   // header for our table. Use these setw() offsets in your table
   cout << '[' << setw(2) << 'i' << ']'
      << setw(15) << "address"
      << setw(20) << "hexadecimal"
      << setw(20) << "decimal"
      << setw(18) << "characters"
      << endl;
   cout << "----+"
      << "---------------+"
      << "-------------------+"
      << "-------------------+"
      << "-----------------+\n";

   // set the pointer's value (numLongs - 1)*sizeof(long)
   // up in the stack
   p = p + (numLongs - 1);
   for (int i = numLongs; i >= 0; --i)
   {
      --p; // decrement down the stack 8 bytes at a time

      cout << '[' << setw(2) << i << ']'
         << setw(15) << (void*)p
         << setw(20) << std::hex << std::showbase << *p
         << setw(20) << std::dec << *p
         << setw(18) << displayCharArray((char*)p) << endl;
   }
}

/***********************************************************
 * SAVED
 * Display success message for saving favorite-nums.txt
 ***********************************************************/
void saved()
{
   cout << "Favorite Numbers have been saved at favorite-nums.txt\n";
}

/***********************************************************
 * FAILED SAVE
 * Display message for failure of saving favorite-nums.txt
 ***********************************************************/
void failedSave()
{
   cout << "Error: Favorite Numbers have failed saving to favorite-nums.txt\n";
}

/******************************************************
 * MAIN
 * This function take you to the various exploits
 *****************************************************/
int main()
{
   // prompt
   cout << "  1. Array index\n"
        << "  2. Pointer subterfuge\n"
        << "  3. ARC injection\n"
        << "  4. VTable spraying\n"
        << "  5. Stack smashing\n"
        << "  6. Heap spraying\n"
        << "  7. Integer overflow\n"
        << "  8. ANSI-Unicode conversion\n"
        << "> ";
   int select;
   cin >> select;

   switch (select)
   {
      case 1:
         arrayExploit();
         arrayWorking();
         break;
      case 2:
         subterfugeExploit();
         break;
      case 3:
         arcWorking();
         arcExploit();
         break;
      case 4:
         vtableExploit();
         break;
      case 5:
         stackExploit();
         break;
      case 6:
         heapExploit();
         break;
      case 7:
         intExploit();
         break;
      case 8:
         ansiWorking();
         ansiExploit();
         break;
      default:
         cout << "Unknown option " << select << endl;
   }
   
   int input = 5;

   return 0;
}

/**************************************************************
 **************************************************************
 *******************    SUBTERFUGE    *************************
 **************************************************************
 **************************************************************/

/****************************************
 * Pointer Subterfuge Vulnerability
 * 1. There must be a pointer used in the code.
 * 2. There must be a way to overwrite the pointer
 * 3. After the pointer is overwritten, the pointer is dereferenced
 ****************************************/
void subterfugeVulnerability(long * array, int size)
{
   long int buffer[2] = {0, 1};
   const char * message = "All is safe; nothing bad happened\n";  // 1. Pointer

   for (int i = 0; i < size; i++)  // 2. Overwrite
      buffer[i] = array[i];

   cout << message;                // 3. Dereference
   
}

/****************************************
 * Pointer Subterfuge Exploitation
 * 1. The attacker must exploit a vulnerability allowing
 *    unintended access to the pointer
 * 2. The attacker must be able to provide a new pointer
 *    referring to data altering the normal flow of the program
 ****************************************/
void subterfugeExploit()
{
   // an attacker's array
   long int array[3] =             // 1. Exploit
   {
      0,
      1,
      (long int)"!!!!!!!!!!!!! You've been hacked !!!!!!!!!!!!!\n"
      // 2. Provide pointer
   };

   // exploit it
   subterfugeVulnerability(array, 3);   
}

/**************************************************************
 **************************************************************
 ********************     ARRAY      **************************
 **************************************************************
 **************************************************************/

/*************************************
 * ARRAY VULNERABILTY
 * 1. There must be an array and an array index variable
 * 2. The array index variable must be reachable through external input.
 * 3. There must not be bounds checking on the array index variable.
 ****************************************/
void arrayVulnerability()
{
    string pieces[4] = {"eggs", "milk", "cereal", "fruit"};
	
}

/**************************************
 * ARRAY WORKING
 * Call arrayVulnerability() in a way that does
 * not yield unexpected behavior
 *************************************/
void arrayWorking(int input)
{
    arrayVulnerability();
    string title = "Lets add bread to the list";
    string pieces[4] = {"eggs", "milk", "cereal", "fruit"};
    cout << "What order should we pick up the grocerries, there is already 4 things on the list put in number 1-5:  ";
	int userInput;
	cin >> userInput;
	pieces[userInput] = "bread";
	cout << "The memory location for your input is ";
	cout <<  + &pieces[userInput] << endl;
	
}

/**************************************
 * ARRAY EXPLOIT
 * 1. The attacker provides an array index value outside the expected range
 * 2. The attacker must be able to provide input or redirect
 *    existing input into the array at the index he provided
 * 3. The injected value must alter program state in a way
 *    that is desirable to the attacker
 *************************************/
void arrayExploit(int input)
{
    string pieces[4] = {"eggs", "milk", "cereal", "fruit"};
    arrayVulnerability();
    bool authenticated = true;
    cout << "The memory address for outside the array is ";
    cout <<  &pieces[input];
  
}

/**************************************************************
 **************************************************************
 ********************      ARC       **************************
 **************************************************************
 **************************************************************/

/*********************************
 * ARC VULNERABILITY
 * 1. There must be a function pointer used in the code.
 * 2. Through some vulnerability, there must be a way for user input
 *    to overwrite the function pointer. This typically happens through
 *    a stack buffer vulnerability.
 * 3. After the memory is overwritten, the function pointer must
 *    be dereferenced
 ********************************/
void arcVulnerability(const long favoriteNums[], const int & length)
{
   long buffer[8]; // limit 8 longs
   void (* endMessage)() = saved;
   for(int i = 0; i < length; ++i)
   {
      buffer[i] = favoriteNums[i];
   }

   // simulate saving
   cout << "Now saving favorite numbers\n";

   (*endMessage)();
}

/*********************************
 * ARC EXPLOIT
 * 1. The attacker must exploit a vulnerability allowing
 *    unintended access to the function pointer
 * 2. The attacker must have the address to another function
 *    which is to be used to replace the existing function pointer
  ********************************/
void arcExploit()
{
   // create a 128 character-string
   long numbers[9] = {
      123, 321, 432, 543, 654,
      765, 876, 9999, (long)failedSave
   };
   arcVulnerability(numbers, 9 /*length*/);
   return;
}

/***********************************************************
 * ARC INJECTION WORKING
 * Initiate normal behavior of arcVulerability()
 **********************************************************/
void arcWorking()
{
   long numbers[8] = {
      123, 321, 432, 543, 654,
      765, 876, 9999
   };
   arcVulnerability(numbers, 8 /*length*/);
   return;
}

/**************************************************************
 **************************************************************
 ********************     VTABLE     **************************
 **************************************************************
 **************************************************************/

/***********************************
 * VULNERABILITY
 * 1. The vulnerable class must be polymorphic.
 * 2. The class must have a buffer as a member variable.
 * 3. Through some vulnerability, there must be a way for user input
 *    to overwrite parts of the VTable.
 * 4. After a virtual function pointer is overwritten,
 *    the virtual function must be called.
 **********************************/
class Vulnerability
{
};

/************************************
 * VTABLE EXPLOIT
 * 1. Through some vulnerability, the VTable pointer
 *     or a function pointer within the VTable must be overwritten
 * 2. The attacker must have the address to another VTable pointer
 *     or a function pointer
 ***********************************/
void vtableExploit()
{
}


/**************************************************************
 **************************************************************
 ********************    STACK       **************************
 **************************************************************
 **************************************************************/

/***********************************************
 * STACK VULNERABILITY
 * 1. There must be a buffer on the stack
 * 2. the buffer must be reachable from an external input
 * 3. The mechanism to fill the buffer must not check the correct buffersize
 **********************************************/
void stackVulnerability(/* feel free to add parameters */)
{

}

/*********************************************
 * STACK EXPLOIT
 * 1. The attacker must provide more data into the
 *    outwardly facing buffer than the buffer is designed to hold
 * 2. The attacker must know where the the stack pointer resides
 *    on the stack. This should be just beyond the end of the buffer
 * 3. The attacker must insert machine language instructions in the buffer.
 *    This may occur before, after, or even around the stack pointer. The
 *    machine language could be already compiled code in the program
 * 4. The attacker must overwrite the stack pointer. The old value,
 *    directing the flow of the program after the function is returned,
 *    must be changed from the calling function to the provided
 *    machine language in step 3.
 *********************************************/
void stackExploit()
{

}

/**************************************************************
 **************************************************************
 ********************      HEAP      **************************
 **************************************************************
 **************************************************************/


/*************************************
 * HEAP VULNERABILITY
 * 1. There must be two adjacent heap buffers.
 * 2. The first buffer must be reachable through external input.
 * 3. The mechanism to fill the buffer from the external input must
 *    not correctly check for the buffer size.
 * 4. The second buffer must be released before the first.
 *************************************/
void heapVulnerability(bool testFlag, char fakeInput[])
{
	char * bufferOne = (char *) malloc(16);
	char * bufferTwo = (char *) malloc(24);
	memcpy(bufferTwo, "nothing here", sizeof(char));

	cout << " Please enter the hash: ";

	if (!testFlag)
	{
		cin.getline(fakeInput, 24);
	}
	memcpy(bufferOne, fakeInput, sizeof(char));
	cout << bufferOne << endl;
	cout << bufferTwo << endl;
	free(bufferTwo);
	free(bufferOne);
}
/*************************************
 * HEAP WORKING
 ***********************************/
void heapWorking()
{
	const char * shortHash = "0x3214432";
	heapVulnerability(true, (char *)shortHash);
}
/*************************************
 * HEAP EXPLOIT
 * 1. The attacker must provide more data into the outwardly facing
 *    heap buffer than the buffer is designed to hold
 * 2. The attacker must know the layout of the Memory Control Block (MCB)
 *    (essentially a linked list) residing just after the buffer
 * 3. The attacker must provide a new MCB containing both the location
 *    of the memory overwrite and the new data to be overwritten
 ***********************************/
void heapExploit()
{
	char exploitInput[42]= "lorem ipsum qoud est sordium Deus Mei";
	heapWorking();
	heapVulnerability(true, exploitInput);
}


/**************************************************************
 **************************************************************
 *******************    INTEGER      **************************
 **************************************************************
 **************************************************************/

/********************************************
 * INTEGER VULNERABILITY
 * 1. There must be a security check represented by an expression.
 * 2. The expression must have the potential for overflow.
 * 3. At least one of the numbers used to compute the sentinel
 *    must be reachable through external input.
 *********************************************/
void intVulnerability(/* feel free to add parameters */)
{
}

/**********************************************
 * INTEGER EXPLOIT
 * 1. Provide input, either a buffer size or a single value,
 *    that is directly or indirectly used in the vulnerable expression
 * 2. The input must exceed the valid bounds of the data-type,
 *    resulting in an overflow or underflow condition
 **********************************************/
void intExploit()
{
}


/**************************************************************
 **************************************************************
 ******************    ANSI-Unicode    ************************
 **************************************************************
 **************************************************************/

/*********************************************************
 * ANSI - UNICODE VULNERABILITY
 * 1. There must be a buffer where the basetype is greater than one.
 * 2. Validation of the buffer must check the size of the buffer
 *    rather than the number of elements in the buffer.
 ********************************************************/
void ansiVulnerability(char phrase[])
{
   int asciiPhrase[5]; // the buffer
   int importantNums[15] = { 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377 };

   cout << "\nUser Input: " << phrase;
   cout << "\nimportantNums before: ";
   for (int i = 0; i < 15; i++)
      cout << importantNums[i] << " ";

   // convert the first 5 letters to ASCII values
   for (int i = 0; i < sizeof(asciiPhrase); i++) // check size instead of num el
      asciiPhrase[i] = (int)phrase[i];

   cout << "\nasciiPhrase: ";
   for (int i = 0; i < 5; i++)
      cout << asciiPhrase[i] << " ";
   cout << "\nimportantNums after: ";
   for (int i = 0; i < 15; i++)
      cout << importantNums[i] << " ";
   cout << endl;
}

/***********************************************
 * ASCI - UNICODE EXPLOIT
 * 1. The attacker must provide more than half as much data
 *    into the outwardly facing buffer as it is designed to hold
 **********************************************/
void ansiExploit()
{
   // simulate user input
   char phrase[64] = "101010101010101010101010101010101010101010101010101010101010";

   // this will overrun into importantNums because of its length
   ansiVulnerability(phrase);
}

/**************************************
 * ANSI WORKING
 * Call ansiVulnerability() in a way that does
 * not yield unexpected behavior
 *************************************/
void ansiWorking()
{
   // simulate user input
   char phrase[15] = "Hello world!";

   ansiVulnerability(phrase);
}
